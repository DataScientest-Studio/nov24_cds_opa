# Importation des biblioth√®ques n√©cessaires
import yfinance as yf
import pandas as pd
import numpy as np
import ta
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

# 1. R√©cup√©ration des donn√©es
tickers = ["AAPL", "MSFT", "NVDA", "GOOGL", "AMZN", "META", "AVGO", "TSLA", "COST", "PEP"]
data = {}

# Utilisation d'une date de fin valide
end_date = pd.Timestamp.today().strftime('%Y-%m-%d')

print(f"üîÑ T√©l√©chargement des donn√©es historiques jusqu'√† {end_date}")
for ticker in tickers:
    try:
        df = yf.download(ticker, start="2020-01-01", end=end_date)
        if df.empty or len(df) < 60:  # V√©rification des donn√©es minimales
            print(f"‚ö†Ô∏è Donn√©es insuffisantes pour {ticker}, ignor√©")
            continue

        # V√©rification des colonnes requises
        required_cols = ["Open", "High", "Low", "Close", "Volume"]
        if not all(col in df.columns for col in required_cols):
            print(f"‚ö†Ô∏è Colonnes manquantes pour {ticker}, ignor√©")
            continue

        df = df.dropna()
        df['Ticker'] = ticker
        data[ticker] = df
        print(f"‚úÖ {ticker}: {len(df)} jours de donn√©es t√©l√©charg√©s")
    except Exception as e:
        print(f"‚ùå Erreur lors du t√©l√©chargement de {ticker}: {str(e)}")

if not data:
    raise ValueError("Aucune donn√©e r√©cup√©r√©e pour les tickers sp√©cifi√©s")

# 2. Calcul des indicateurs techniques
print("\nüßÆ Calcul des indicateurs techniques")
for ticker in list(data.keys()):
    df = data[ticker]

    try:
        # Impression pour le d√©bogage
        print(f"Debug - {ticker} colonnes avant ajout des indicateurs: {df.columns.tolist()}")

        # Aplatir les colonnes si elles sont de type MultiIndex
        if isinstance(df.columns, pd.MultiIndex):
            df.columns = [f"{col[0]}" for col in df.columns]

        # V√©rification et conversion des colonnes en 1D si n√©cessaire
        for col in ["Open", "High", "Low", "Close", "Volume"]:
            if df[col].ndim > 1:
                df[col] = df[col].squeeze()

        # Ajout des indicateurs techniques
        df = ta.add_all_ta_features(
            df,
            open="Open",
            high="High",
            low="Low",
            close="Close",
            volume="Volume",
            fillna=True
        )

        # D√©finition de la cible : hausse (1) ou baisse (0) le jour suivant
        df["Target"] = (df["Close"].shift(-1) > df["Close"]).astype(int)

        # Suppression des lignes avec valeurs manquantes
        clean_df = df.dropna()

        # V√©rifier qu'il reste suffisamment de donn√©es
        if len(clean_df) < 50:
            print(f"‚ö†Ô∏è Donn√©es insuffisantes apr√®s nettoyage pour {ticker}, ignor√©")
            continue

        data[ticker] = clean_df
        print(f"‚úÖ {ticker}: {len(clean_df)} jours exploitables")
    except Exception as e:
        print(f"‚ùå Erreur lors du calcul des indicateurs pour {ticker}: {str(e)}")
        # Supprimer le ticker qui a √©chou√©
        if ticker in data:
            del data[ticker]

# 3. Entra√Ænement et √©valuation du mod√®le pour chaque titre
print("\nü§ñ Entra√Ænement des mod√®les")
results = {}

for ticker in list(data.keys()):  # Utiliser une copie des cl√©s pour √©viter les erreurs pendant l'it√©ration
    if ticker not in data:
        continue

    df = data[ticker]

    # V√©rifier si Target existe dans le DataFrame
    if "Target" not in df.columns:
        print(f"‚ö†Ô∏è Colonne Target manquante pour {ticker}, ignor√©")
        continue

    # S√©lection des features (exclure colonnes non num√©riques et la cible)
    try:
        features = df.select_dtypes(include=[np.number]).columns.tolist()
        features = [col for col in features if col not in ["Target"]]

        if not features:
            print(f"‚ö†Ô∏è Pas de caract√©ristiques valides pour {ticker}, ignor√©")
            continue

        X = df[features]
        y = df["Target"]

        # V√©rification des donn√©es avant s√©paration
        if len(X) < 30:
            print(f"‚ö†Ô∏è Ensemble de donn√©es trop petit pour {ticker}, ignor√©")
            continue

        # Normalisation des caract√©ristiques
        scaler = StandardScaler()
        X_scaled = scaler.fit_transform(X)

        # Division chronologique des donn√©es (pas de m√©lange)
        train_size = int(len(X) * 0.8)
        X_train, X_test = X_scaled[:train_size], X_scaled[train_size:]
        y_train, y_test = y[:train_size], y[train_size:]

        if len(np.unique(y_train)) < 2 or len(np.unique(y_test)) < 2:
            print(f"‚ö†Ô∏è Classes d√©s√©quilibr√©es pour {ticker}, ignor√©")
            continue
    except Exception as e:
        print(f"‚ùå Erreur lors de la pr√©paration des donn√©es pour {ticker}: {str(e)}")
        continue

    try:
        # Entra√Ænement du mod√®le avec plus d'arbres pour am√©liorer la stabilit√©
        model = RandomForestClassifier(n_estimators=200, max_depth=10, random_state=42, n_jobs=-1)
        model.fit(X_train, y_train)

        # √âvaluation
        y_pred = model.predict(X_test)
        acc = accuracy_score(y_test, y_pred)

        # Stockage des r√©sultats
        results[ticker] = {
            "model": model,
            "accuracy": acc,
            "features": features,
            "scaler": scaler,
            "report": classification_report(y_test, y_pred, output_dict=True),
            "balance": {
                "train": dict(pd.Series(y_train).value_counts(normalize=True)),
                "test": dict(pd.Series(y_test).value_counts(normalize=True))
            }
        }

        print(f"\nüîç R√©sultats pour {ticker}:")
        print(f"Pr√©cision: {acc:.4f}")
        print(f"Distribution train: Hausse={results[ticker]['balance']['train'].get(1, 0):.2f}, "
              f"Baisse={results[ticker]['balance']['train'].get(0, 0):.2f}")
        print(f"Distribution test: Hausse={results[ticker]['balance']['test'].get(1, 0):.2f}, "
              f"Baisse={results[ticker]['balance']['test'].get(0, 0):.2f}")
        print(classification_report(y_test, y_pred))

    except Exception as e:
        print(f"‚ùå Erreur lors de l'entra√Ænement pour {ticker}: {str(e)}")

if not results:
    print("\n‚ùå Aucun mod√®le n'a pu √™tre entra√Æn√© correctement. Probl√®me potentiel avec le format des donn√©es.")
    print("V√©rification des donn√©es disponibles:")
    for ticker in data:
        print(f"{ticker}: {len(data[ticker])} lignes, {len(data[ticker].columns)} colonnes")
        print(f"Premi√®res colonnes: {list(data[ticker].columns[:5])}")
        if 'Target' in data[ticker].columns:
            target_count = data[ticker]['Target'].value_counts()
            print(f"Distribution de Target: {target_count.to_dict()}")
        else:
            print("‚ùå Colonne Target manquante")
        print("---")

# 4. Visualisation des pr√©cisions et caract√©ristiques importantes
if results:
    plt.figure(figsize=(12, 6))
    accuracies = pd.Series({k: v['accuracy'] for k, v in results.items()})
    accuracies.sort_values().plot(kind='barh', color='skyblue')
    plt.title("üìà Pr√©cision du mod√®le RandomForest par titre")
    plt.xlabel("Accuracy")
    plt.axvline(x=0.5, color='red', linestyle='--', label='Baseline (50%)')
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig('accuracy_results.png')
    plt.show()
else:
    print("‚ùå Aucun mod√®le n'a √©t√© entra√Æn√© avec succ√®s. Impossible de g√©n√©rer des visualisations.")

# 5. Analyse des caract√©ristiques les plus importantes (pour le meilleur mod√®le)
if results:
    best_ticker = max(results, key=lambda x: results[x]['accuracy'])
    best_model = results[best_ticker]['model']
    features = results[best_ticker]['features']

    # Importance des caract√©ristiques
    plt.figure(figsize=(12, 8))
    importances = pd.Series(best_model.feature_importances_, index=features)
    importances.sort_values(ascending=False).head(15).plot(kind='barh', color='lightgreen')
    plt.title(f"üèÜ Top 15 caract√©ristiques importantes pour {best_ticker}")
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig('feature_importance.png')
    plt.show()

    print(f"\nüèÜ Meilleur mod√®le: {best_ticker} avec une pr√©cision de {results[best_ticker]['accuracy']:.4f}")

# 6. Pr√©diction pour le dernier jour disponible
print("\nüîÆ Pr√©dictions pour le prochain jour de trading:")
for ticker in results:
    try:
        current_data = data[ticker].iloc[-1:].copy()
        features = results[ticker]['features']
        scaler = results[ticker]['scaler']
        model = results[ticker]['model']

        X_current = current_data[features]
        X_scaled = scaler.transform(X_current)
        prediction = model.predict(X_scaled)[0]
        proba = model.predict_proba(X_scaled)[0]

        direction = "üü¢ HAUSSE" if prediction == 1 else "üî¥ BAISSE"
        confidence = proba[prediction]

        print(f"{ticker}: {direction} (confiance: {confidence:.2f})")
    except Exception as e:
        print(f"‚ùå Erreur lors de la pr√©diction pour {ticker}: {str(e)}")

print("\n‚ö†Ô∏è Note: Ces pr√©dictions sont bas√©es sur l'analyse technique historique et ne constituent pas des conseils d'investissement.")
